name: "Prepare infra meeting notes release"

# https://docs.github.com/en/enterprise-cloud@latest/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_dispatchinputs
on:
  workflow_dispatch:
    inputs:
      milestone_id:
        description: 'Milestone id to prepare for release'
        required: true
        default: '1'
        type: string
      milestone_name:
        description: 'Milestone name'
        required: true
        default: 'current'
        type: string
      next_milestone_id:
        description: '"Next" milestone id'
        required: true
        default: '4'
        type: string
      next_milestone_name:
        description: '"Next" milestone name'
        required: true
        default: 'next'
        type: string


jobs:

  # https://localheinz.com/blog/2022/01/24/creating-releases-with-github-actions/
  release:
    name: "Prepare infra meeting notes release"
    runs-on: "ubuntu-latest"
    steps:

      # - name: "Determine tag"
      #   run: "echo \"RELEASE_TAG=${GITHUB_REF#refs/tags/}\" >> $GITHUB_ENV"
      # - name: Generate token
      #   id: generate_token
      #   uses: tibdex/github-app-token@v1
      #   with:
      #     app_id: ${{ secrets.INFRA_GITHUB_APP_ID }}
      #     private_key: ${{ secrets.INFRA_GITHUB_APP_PRIVATE_KEY }}
      - name: View context attributes
        uses: actions/github-script@v6
        with:
          script: console.log(context)
      - name: "Gather release body"
        uses: "actions/github-script@v6"
        with:
          result-encoding: string
          script: |
            const getMilestoneIssuesAsMarkdown = async function(milestone, milestoneName) {
              const opts = github.rest.issues.listForRepo.endpoint.merge({
                ...context.issue,
                milestone,
                state: 'all'
              })
              const issues = await github.paginate(opts)

              let closedIssues = []
              let openIssues = []
              for (const issue of issues) {
                if (issue.state == 'closed') {
                  closedIssues.push(issue)
                } else {
                  openIssues.push(issue)
                }
              }
              
              let returnedBody = ''
              if (count(closedIssues) > 0) `## Closed issues in [${milestoneName} milestone](${context.payload.repository.html_url}/milestones/${milestone}):`
              
              for (const issue of closedIssues) {
                returnedBody = returnedBody.concat("\r\n").concat(`  * [${issue.title}](${issue.html_url})`)
              }

              if (count(openIssues) > 0) returnedBody = returnedBody.concat("\r\n\r\n").concat(`## Open issues in [${milestoneName} milestone](${context.payload.repository.html_url}/milestones/${milestone}):`

              for (const issue of openIssues) {
                returnedBody = returnedBody.concat("\r\n").concat(`  * [${issue.title}](${issue.html_url})`)
              }
              return returnedBody
            }

            console.log('start')

            const nextMilestoneId = 10
            releaseBody = await getMilestoneIssuesAsMarkdown(context.payload.inputs.milestone_id, context.payload.inputs.milestone_name)
            releaseBody = releaseBody.concat("\r\n<hr>")
            releaseBody = await getMilestoneIssuesAsMarkdown(context.payload.inputs.next_milestone_id, context.payload.inputs.next_milestone_name)

            console.log('releaseBody:')
            console.log(releaseBody)
            return releaseBody
      - name: "Create release"
        uses: "actions/github-script@v6"
        with:
          script: |
            try {
              await github.rest.repos.createRelease({
                draft: true,
                generate_release_notes: true,
                name: process.env.RELEASE_TAG,
                owner: context.repo.owner,
                prerelease: false,
                repo: context.repo.repo,
                tag_name: process.env.RELEASE_TAG,
                body: releaseBody,
              });
            } catch (error) {
              core.setFailed(error.message);
            }
